変換

トランスフォーメーションを使用すると、ワールド内でオブジェクトが描画される場所を変更できます。
たとえば、ブロックを描画する関数は、軸平行ブロックのみを描画できます。
最初に回転変換を設定すると、回転したブロックを作成できます。
また、スプライトは常に xy 平面に平行に描画されます。
変換を設定することで、これを変更できます。
関数には、変換を設定する関数と変換を追加する関数の 2 種類があります。

・d3d_transform_set_identity() 
　変換を恒等に設定します (変換なし)。

・d3d_transform_set_translation(xt,yt,zt) 
　変換を指定されたベクトルの平行移動に設定します。

・d3d_transform_set_scaling(xs,ys,zs) 
　指定された量のスケーリングに変換を設定します。

・d3d_transform_set_rotation_x(angle) 
　指定された量で x 軸を中心とした回転に変換を設定します。

・d3d_transform_set_rotation_y(angle) 
　変換を指定された量の y 軸周りの回転に設定します。

・d3d_transform_set_rotation_z(angle) 
　指定された量で、変換を z 軸を中心とした回転に設定します。

・d3d_transform_set_rotation_axis(xa,ya,za,angle) 
　指定された量のベクトルで指定された軸を中心とした回転に変換を設定します。

・d3d_transform_add_translation(xt,yt,zt) 
　指定されたベクトルに平行移動を追加します。

・d3d_transform_add_scaling(xs,ys,zs) 
　指定された量でスケーリングを追加します。

・d3d_transform_add_rotation_x(angle) 
　指定された量で x 軸周りの回転を追加します。

・d3d_transform_add_rotation_y(angle) 
　指定された量で y 軸周りの回転を追加します。

・d3d_transform_add_rotation_z(angle) 
　指定された量で z 軸周りの回転を追加します。

・d3d_transform_add_rotation_axis(xa,ya,za,angle) 
　指定された量のベクトルで指定された軸の周りに回転を追加します。



回転とスケーリングは、描画されるオブジェクトに関してではなく、
ワールドの原点に関して行われることに注意してください。
オブジェクトが原点にない場合、別の場所にも移動しますが、これは望ましくありません。

だから例えば。オブジェクトを独自の x 軸上で回転させるには、最初にオブジェクトを原点に移動し、
次に回転させ、最後に元の位置に移動する必要があります。
これが、変換を追加する関数の目的です。



次の例は、これをよりよく説明している可能性があります。
位置 (100,100,10) に描画したいスプライト spr があるとします。
これを行うには、次のコードを使用できます

　d3d_transform_set_translation(100,100,10);
　draw_sprite(spr,0,0,0);
　d3d_transform_set_identity();



平行移動を使用するため、スプライトを位置 (0,0) に描画する必要があることに注意してください。
 (これは、現在のインスタンスの深度が 0 であることを前提としています! よくわからない場合は、最初に深度を設定してください。) 

これをファースト パーソン シューティング ゲームで使用すると、スプライトは表示されません。
その理由は、それがまだ xy 平面に平行だからです。
 x 軸 (または y 軸) に沿って 90 度以上回転させます。
したがって、回転を追加する必要があります。

順序を覚えておいてください。
最初にスプライトを回転させてから、平行移動する必要があります。
したがって、次のコードを使用できます。

  d3d_transform_set_identity();
  d3d_transform_add_rotation_x(90);
  d3d_transform_add_translation(100,100,10);
  draw_sprite(spr,0,0,0);
  d3d_transform_set_identity();



場合によっては、現在の変換を一時的に保存したい場合があります。

たとえば、別の変換を追加してから古い変換を復元する場合です
 (これは、階層モデルを描画するときによく発生します)。

このために、現在の変換をスタックにプッシュし、後でそれをスタックからポップして、
再び現在の変換にすることができます。

これには、次の関数があります。

・d3d_transform_stack_clear() 
　変換のスタックをクリアします。

・d3d_transform_stack_empty() 
　変換スタックが空かどうかを返します。

・d3d_transform_stack_push() 
　現在の変換をスタックにプッシュします。
　スタックにそこにプッシュする余地があったかどうかを返します
　(変換をポップするのを忘れると、スタックのスペースがすぐに不足してしまいます)。

・d3d_transform_stack_pop() 
　スタックから最上位の変換をポップし、それを現在のものにします。
　スタックに変換があったかどうかを返します。

・d3d_transform_stack_top() 
　最上位の変換を現在のものにしますが、スタックから削除しません。
　スタックに変換があったかどうかを返します。

・d3d_transform_stack_discard() 
　スタックから最上位の変換を削除しますが、現在のものにはしません。
　スタックに変換があったかどうかを返します。



変換の使用は強力なメカニズムです。
ただし、変換が完了したら、常に ID に戻すように注意してください。

